<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  </head>
  <script src="https://unpkg.com/@esotericsoftware/spine-webgl@4.1.*/dist/iife/spine-webgl.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
    }
  </style>

  <body>
    <canvas
      id="canvas"
      style="position: fixed; width: 100%; height: 100%; bottom: 0; z-index: -1"
    ></canvas>
    <div style="padding: 8; height: auto; background: white">
      <label for="animation-options">Animation:</label>
      <select name="animation-options" id="animation-options"></select>

      <label for="skin-options">Skin:</label>
      <select name="skin-options" id="skin-options"></select>
    </div>
    <script>
      class App {
        constructor() {
          this.skeleton = null;
          this.skeletonData = null;
          this.animationState = null;

          this.canvas = null;
          this.count = 0;
          this.pma = false;

          // this.scale = 1;
          // this.atlasAsset = "assets/spineboy-pma.atlas";
          // this.skelAsset = "assets/spineboy-pro.skel";
          // this.animation = "run";

          this.scale = 4;
          this.atlasAsset = "assets/spine_meeko_4.1.atlas";
          this.skelAsset = "assets/spine_meeko_4.1.skel";
          this.animation = "walk-ex";
          this.animationNames = [];

          this.selectedSkins = [];

          // this skins1 scrapped from .json
          this.skins1 = [
            "char_m/char_face/face-main",
            "char_m/char_face/face-sad",
            "char_m/char_face/face-happy",
            "char_m/char_hair_b/char_hair_b1",
            "char_m/char_hair_b/char_hair_b2",
            "char_m/char_hair_b/char_hair_b3",
            "cos_m/cos_suit",
            "cos_m/cos_top2",
            "cos_m/cos_overall1",
            "cos_m/cos_dress2",
          ];

          // this skins2 is from reading skeleten viewer
          this.skins2 = [
            "char_m/char_face/face-happy",
            "char_m/char_face/face-main",
            "char_m/char_face/face-sad",
            "char_m/char_face/face-serious",
            "char_m/char_face/face-surprised",
            "char_m/char_hair_b/char_hair_b1",
            "char_m/char_hair_b/char_hair_b2",
            "char_m/char_hair_b/char_hair_b3",
            "char_m/char_hair_b/char_hair_b4",
            "char_m/char_hair_b/char_hair_f",
            "char_m/char_race_m/char_race_ears",
            "char_m/char_race_m/char_race_tail_m1",
            "char_m/char_race_m/char_race_tail_m2",
            "cos_m/cos_acc_m_/cos_acc_m2",
            "cos_m/cos_btm",
            "cos_m/cos_dress",
            "cos_m/cos_dress2",
            "cos_m/cos_overall",
            "cos_m/cos_overall1",
            "cos_m/cos_suit",
            "cos_m/cos_top",
            "cos_m/cos_top2",
          ];
        }

        loadAssets(canvas) {
          // Load the skeleton file.
          canvas.assetManager.loadBinary(this.skelAsset);
          // Load the atlas and its pages.
          canvas.assetManager.loadTextureAtlas(this.atlasAsset);
        }

        initialize(canvas) {
          this.canvas = canvas;
          let assetManager = canvas.assetManager;

          // Create the texture atlas.
          var atlas = assetManager.require(this.atlasAsset);

          // Create a AtlasAttachmentLoader that resolves region, mesh, boundingbox and path attachments
          var atlasLoader = new spine.AtlasAttachmentLoader(atlas);

          // Create a SkeletonBinary instance for parsing the .skel file.
          var skeletonBinary = new spine.SkeletonBinary(atlasLoader);

          // Set the scale to apply during parsing, parse the file, and create a new skeleton.
          skeletonBinary.scale = this.scale;
          this.skeletonData = skeletonBinary.readSkeletonData(
            assetManager.require(this.skelAsset)
          );
          console.log(
            "ðŸš€ ~ App ~ initialize ~ this.skeletonData:",
            this.skeletonData
          );

          this.skeleton = new spine.Skeleton(this.skeletonData);

          // Create an AnimationState, and set the "run" animation in looping mode.
          var animationStateData = new spine.AnimationStateData(
            this.skeletonData
          );
          this.animationState = new spine.AnimationState(animationStateData);
          this.changeAnimation(this.animation);

          this.createUI();
        }

        createUI() {
          // create animation options
          const selectAnimation = document.getElementById("animation-options");
          selectAnimation.onchange = (e) =>
            this.changeAnimation(e.target.value);

          this.skeletonData.animations.map((i) => {
            const newNode = document.createElement("option");
            newNode.value = i.name;
            const textNode = document.createTextNode(i.name);
            newNode.appendChild(textNode);
            selectAnimation.appendChild(newNode);
          });

          // create skin options
          const selectSkin = document.getElementById("skin-options");
          selectSkin.onchange = (e) => this.changeSkin(e.target.value);

          this.skeletonData.skins.map((i) => {
            const newNode = document.createElement("option");
            newNode.value = i.name;
            const textNode = document.createTextNode(i.name);
            newNode.appendChild(textNode);
            selectSkin.appendChild(newNode);
          });
        }

        changeAnimation(name) {
          console.log("changeAnimation", name);
          this.animationState.setAnimation(0, name, true);
          this.animation = name;
        }

        changeSkin(name) {
          console.log("changeSkin", name);

          // Create a new skin from all the selected skins.
          let newSkin = new spine.Skin("custom-skin");
          newSkin.addSkin(this.skeletonData.findSkin(name));
          // for (var skinName of this.selectedSkins) {
          //   console.log("skins", skinName);
          // }
          this.skeleton.setSkin(newSkin);
          this.skeleton.setToSetupPose();
          this.skeleton.updateWorldTransform();

          // Calculate the bounds so we can center and zoom
          // the camera such that the skeleton is in full view.
          // let offset = new spine.Vector2(),
          //   size = new spine.Vector2();
          // this.skeleton.getBounds(offset, size);
          // this.lastBounds = { offset: offset, size: size };
        }

        // addSkin(skinName) {
        //   if (this.selectedSkins.indexOf(skinName) != -1) return;
        //   this.selectedSkins.push(skinName);
        //   let thumbnail = this.skinThumbnails[skinName];
        //   thumbnail.isSet = true;
        //   thumbnail.style.filter = "none";
        //   this.updateSkin();
        // }

        // removeSkin(skinName) {
        //   let index = this.selectedSkins.indexOf(skinName);
        //   if (index == -1) return;
        //   this.selectedSkins.splice(index, 1);
        //   let thumbnail = this.skinThumbnails[skinName];
        //   thumbnail.isSet = false;
        //   thumbnail.style.filter = "grayscale(1)";
        //   this.updateSkin();
        // }

        // updateSkin() {
        //   console.log("updateSkin()");
        //   // Create a new skin from all the selected skins.
        //   let newSkin = new spine.Skin("custom-skin");
        //   for (var skinName of this.selectedSkins) {
        //     console.log(skinName);
        //     newSkin.addSkin(this.skeletonData.findSkin(skinName));
        //   }
        //   this.skeleton.setSkin(newSkin);
        //   this.skeleton.setToSetupPose();
        //   this.skeleton.updateWorldTransform();

        //   // Calculate the bounds so we can center and zoom
        //   // the camera such that the skeleton is in full view.
        //   let offset = new spine.Vector2(),
        //     size = new spine.Vector2();
        //   this.skeleton.getBounds(offset, size);
        //   this.lastBounds = { offset: offset, size: size };
        // }

        update(canvas, delta) {
          // console.log("updating", delta);
          // Update the animation state using the delta time.
          this.animationState.update(delta);
          // Apply the animation state to the skeleton.
          this.animationState.apply(this.skeleton);
          // Let the skeleton update the transforms of its bones.
          this.skeleton.updateWorldTransform();
        }

        render(canvas) {
          let renderer = canvas.renderer;
          // Resize the viewport to the full canvas.
          renderer.resize(spine.ResizeMode.Expand);

          // Clear the canvas with a light gray color.
          canvas.clear(0.2, 0.2, 0.2, 1);

          // Begin rendering.
          renderer.begin();
          // Draw the skeleton
          renderer.drawSkeleton(this.skeleton, this.pma);
          // Complete rendering.
          renderer.end();
        }
      }

      new spine.SpineCanvas(document.getElementById("canvas"), {
        app: new App(),
      });
    </script>
  </body>
</html>
